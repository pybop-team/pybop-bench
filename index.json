{"project": "PyBOP", "project_url": "https://github.com/pybop-team/pybop", "show_commit_url": "#", "hash_length": 8, "revision_to_hash": {"325": "6e5c00781643987c467654379d2352df94317055", "534": "760ceb84eeb88376740a735b000331d7e2956674", "542": "9e9c067c981febfc1ad7bc6771566bbfc65d4339", "975": "ebc7b628b10c4835f8e842158b44f4622f30d6d2", "978": "aa9a3951b1e24a9f2a1100a1b63e990db8e093dc", "983": "68b4c9bab38978ae80b51dc42064b674efb0b9e2", "994": "7a7e9efbbd98b33773c45c4b6e85e88ffd00bc4a", "998": "896f1b338c888a58f8b769560f51155c2b9c903c", "1038": "75967f7658bdea60b1551da42e03b6ebb8b0d124", "1079": "92abe7ed7504fbcc7a5258071b99114aab9a919c", "1084": "34b7790dc6f7ee2ae36ee3914b50079b98a9889a", "1098": "ecf8be429e718e5bffb8b47addb39ca56b62462f", "1112": "68203df804898d81fe5f0b9b8198a6d1a0126865", "1121": "68c0e49c09c1db7447dbb9986a6579ef1f0b317f", "1158": "8cb625ae73a90067bec8903a2e2720597dd54b96", "1169": "05095987d7aba8a8d267ff55450e82b3e533be7f", "1173": "040a8b1e04f63ead01a5991de9883c38ee14c9a7", "1187": "36b1b11bffab961a70940f7ea97ce703d4973b42", "1206": "8161d732adeb2897655f628c4c875f99868663cb", "1216": "91f03735fae3b5b3433fb6ff2e6b4aa11db325c3", "1222": "6ba3d047a87ff86cd395c1a868a89e898da76b03", "1239": "57e0e8368fbe1da69c0606ae9c472aa80dff7714", "1254": "692b4d5e71a69660b8b989c7bab2559cb54a2901", "1299": "1431f67c9c3474cfe9633f81027f9d980f9a31da", "1304": "b1070ea25bdf8ebac7d33232f6228ffe36ffb5ec", "1336": "54edc3cf2e956a7b7dfd23e5bdbe74e124d44f08", "1346": "490273baeab7428a46d7ff477e49074b69bee3e5", "1362": "0395429a87cfa6cb2662379004c8b540cb4247a7", "1417": "716cc813f5bb3e3901ecdae51d8454b57d4d3aa8", "1420": "074deb64dd0101f3ac8aa27f6b1abe07fe225554", "1445": "0d7596c591fd40f23793aa146e41a1a7b3b8e58f", "1449": "e149cfbcac0fdf0de374763cd97e2538db16d21a", "1564": "4de2c2e8b996ead88f8a48c54a65e5315fa213ee", "1593": "f32c38338843127dd4c291ca57467a478645cb08", "1646": "eed0fd069f6b27c09d9d5e13558286079eddabd4", "1673": "4e8b0bcc8560b2a1b43c964490bc15a6e9b3a5a3", "1731": "2a588e0f68ad727348ac905b6ba576f2157fc24c", "1744": "1ff8115ab11aa00466ca0a616f2108bea04b7230", "1772": "af5df5f4257bf6c2b591651c0932d5b37ec15e26", "1791": "9ac4d01b090ac9df6c07c230cc30336eaa1396c7", "1850": "b49ede48210b8f5f32976ea04eceee88c7deded2", "1910": "d40cc4ff3dfff61da896d68019aca5a41a52b0f6", "1912": "6487bf187a682f24fc237f4d114913c1112f707c", "1949": "4638a60f1bc00afef0bd2c8e179b7c17826289d4", "1962": "2caf7badc3a492b95a870fa9836e5448840f14c5", "1997": "e34099fa90223763dc738a8aba47e929354c811f", "2045": "ddfd905450be886963aed732e6f1e4484a6e075d", "2051": "e6788e450cd49c2fbd59c9e0d290d8aedf30c863", "2121": "737a4f8e4e1e68c8fd99f3b3f755d395c8feeaee", "2132": "08fa1cb58d46cae9424c7ce809ccf52d8ef766ff", "2211": "9e15f90b75c4f5fb04cb17c0807dd0b5e1a2e6fb", "2371": "a5ce284a5d206b71beae5dd871608b468923025a", "2412": "d414460f71a677899516f6f19442b966b6d7a16c", "2439": "1a764707687de91db7ff39e607ab46f3502eaa81", "2496": "cd07b146e93553236132839811618ebd1568499f", "2512": "855b606417e059946796e13da318e481ebc5cf64", "2521": "ab6eca5ef141d02a6b1df096b5dcd425f7cb1f26", "2565": "eb5a632976a874fbe9dd7e8c89d964f1da97ad5c", "2590": "99632b94cdec3cfc9caa8b1f61b751e60e3bb43e", "2597": "7d07f4aa3d25e11d84bffc96a4d7459f26c59048", "2611": "2062c2ff18abbd0e50e7a72c3a4215d725f2bc30", "2637": "f0377a123c0d0d281db93c1bb0533e50102fd181", "2641": "976872a6a815fdfa1425bd9529b4df1566959f80", "2652": "350df28568ad5b49d2143ce545a8631601611664"}, "revision_to_date": {"325": 1700495475000, "534": 1702977995000, "542": 1703062685000, "975": 1710526427000, "978": 1710583883000, "983": 1710757347000, "994": 1710838081000, "998": 1710859303000, "1038": 1711033720000, "1079": 1711396712000, "1084": 1711447503000, "1098": 1711621425000, "1112": 1712314081000, "1121": 1712397450000, "1158": 1712651471000, "1169": 1712856175000, "1173": 1712923822000, "1187": 1713087419000, "1206": 1713285876000, "1216": 1713438189000, "1222": 1713453494000, "1239": 1713690029000, "1254": 1713820250000, "1299": 1714098812000, "1304": 1714138946000, "1336": 1714763168000, "1346": 1715116117000, "1362": 1715255620000, "1417": 1715683748000, "1420": 1715706951000, "1445": 1715890910000, "1449": 1715952609000, "1564": 1717165101000, "1593": 1717663770000, "1646": 1718008039000, "1673": 1718093554000, "1731": 1718710044000, "1744": 1718717412000, "1772": 1719255505000, "1791": 1719595259000, "1850": 1720083999000, "1910": 1720440526000, "1912": 1720440976000, "1949": 1720685301000, "1962": 1720706337000, "1997": 1721116534000, "2045": 1721647280000, "2051": 1721720754000, "2121": 1722428761000, "2132": 1722434870000, "2211": 1722856265000, "2371": 1723792657000, "2412": 1724312259000, "2439": 1724336364000, "2496": 1724832862000, "2512": 1725265914000, "2521": 1725346879000, "2565": 1725880395000, "2590": 1726062429000, "2597": 1726143954000, "2611": 1726325004000, "2637": 1726645152000, "2641": 1726662045000, "2652": 1727172322000}, "params": {"machine": ["SelfHostedRunner"], "python": ["3.12"], "pybamm": [""], "numpy": [""], "scipy": [""], "pints": [""], "branch": ["develop"]}, "graph_param_list": [{"machine": "SelfHostedRunner", "python": "3.12", "pybamm": "", "numpy": "", "scipy": "", "pints": "", "branch": "develop"}], "benchmarks": {"benchmark_model.BenchmarkModel.time_model_predict": {"code": "class BenchmarkModel:\n    def time_model_predict(self, model, parameter_set):\n        \"\"\"\n        Benchmark the predict method of the model.\n    \n        Args:\n            model (pybop.Model): The model class being benchmarked.\n            parameter_set (str): The name of the parameter set being used.\n        \"\"\"\n        self.model.predict(\n            inputs=self.inputs, t_eval=self.t_eval, initial_state=self.init_state\n        )\n\n    def setup(self, model, parameter_set):\n        \"\"\"\n        Setup the model and problem for predict and simulate benchmarks.\n    \n        Args:\n            model (pybop.Model): The model class to be benchmarked.\n            parameter_set (str): The name of the parameter set to be used.\n        \"\"\"\n        # Set random seed\n        set_random_seed()\n    \n        # Create model instance\n        self.model = model(parameter_set=pybop.ParameterSet.pybamm(parameter_set))\n    \n        # Define fitting parameters\n        parameters = pybop.Parameters(\n            pybop.Parameter(\n                \"Current function [A]\",\n                prior=pybop.Gaussian(0.4, 0.02),\n                bounds=[0.2, 0.7],\n                initial_value=0.4,\n            )\n        )\n    \n        # Generate synthetic data\n        sigma = 0.001\n        self.t_eval = np.arange(0, 900, 2)\n        self.init_state = {\"Initial SoC\": 0.5}\n        values = self.model.predict(t_eval=self.t_eval, initial_state=self.init_state)\n        corrupt_values = values[\"Voltage [V]\"].data + np.random.normal(\n            0, sigma, len(self.t_eval)\n        )\n    \n        self.inputs = {\n            \"Current function [A]\": 0.4,\n        }\n    \n        # Create dataset\n        dataset = pybop.Dataset(\n            {\n                \"Time [s]\": self.t_eval,\n                \"Current function [A]\": values[\"Current [A]\"].data,\n                \"Voltage [V]\": corrupt_values,\n            }\n        )\n    \n        # Create fitting problem\n        self.problem = pybop.FittingProblem(\n            model=self.model, dataset=dataset, parameters=parameters\n        )", "min_run_count": 2, "name": "benchmark_model.BenchmarkModel.time_model_predict", "number": 0, "param_names": ["model", "parameter_set"], "params": [["<class 'pybop.models.lithium_ion.echem.SPM'>", "<class 'pybop.models.lithium_ion.echem.SPMe'>"], ["'Chen2020'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "8c071d39605942627ef11760ba0f656f001a5805c2e5314f80a6b249e7feb922", "warmup_time": -1}, "benchmark_model.BenchmarkModel.time_model_simulate": {"code": "class BenchmarkModel:\n    def time_model_simulate(self, model, parameter_set):\n        \"\"\"\n        Benchmark the simulate method of the model.\n    \n        Args:\n            model (pybop.Model): The model class being benchmarked.\n            parameter_set (str): The name of the parameter set being used.\n        \"\"\"\n        self.problem.model.simulate(inputs=self.inputs, t_eval=self.t_eval)\n\n    def setup(self, model, parameter_set):\n        \"\"\"\n        Setup the model and problem for predict and simulate benchmarks.\n    \n        Args:\n            model (pybop.Model): The model class to be benchmarked.\n            parameter_set (str): The name of the parameter set to be used.\n        \"\"\"\n        # Set random seed\n        set_random_seed()\n    \n        # Create model instance\n        self.model = model(parameter_set=pybop.ParameterSet.pybamm(parameter_set))\n    \n        # Define fitting parameters\n        parameters = pybop.Parameters(\n            pybop.Parameter(\n                \"Current function [A]\",\n                prior=pybop.Gaussian(0.4, 0.02),\n                bounds=[0.2, 0.7],\n                initial_value=0.4,\n            )\n        )\n    \n        # Generate synthetic data\n        sigma = 0.001\n        self.t_eval = np.arange(0, 900, 2)\n        self.init_state = {\"Initial SoC\": 0.5}\n        values = self.model.predict(t_eval=self.t_eval, initial_state=self.init_state)\n        corrupt_values = values[\"Voltage [V]\"].data + np.random.normal(\n            0, sigma, len(self.t_eval)\n        )\n    \n        self.inputs = {\n            \"Current function [A]\": 0.4,\n        }\n    \n        # Create dataset\n        dataset = pybop.Dataset(\n            {\n                \"Time [s]\": self.t_eval,\n                \"Current function [A]\": values[\"Current [A]\"].data,\n                \"Voltage [V]\": corrupt_values,\n            }\n        )\n    \n        # Create fitting problem\n        self.problem = pybop.FittingProblem(\n            model=self.model, dataset=dataset, parameters=parameters\n        )", "min_run_count": 2, "name": "benchmark_model.BenchmarkModel.time_model_simulate", "number": 0, "param_names": ["model", "parameter_set"], "params": [["<class 'pybop.models.lithium_ion.echem.SPM'>", "<class 'pybop.models.lithium_ion.echem.SPMe'>"], ["'Chen2020'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "96e89b3a0de27451256ca53259134766dddfea8485af5f64b01d11184c123805", "warmup_time": -1}, "benchmark_model.BenchmarkModel.time_model_simulateS1": {"code": "class BenchmarkModel:\n    def time_model_simulateS1(self, model, parameter_set):\n        \"\"\"\n        Benchmark the simulateS1 method of the model.\n    \n        Args:\n            model (pybop.Model): The model class being benchmarked.\n            parameter_set (str): The name of the parameter set being used.\n        \"\"\"\n        self.problem.model.simulateS1(inputs=self.inputs, t_eval=self.t_eval)\n\n    def setup(self, model, parameter_set):\n        \"\"\"\n        Setup the model and problem for predict and simulate benchmarks.\n    \n        Args:\n            model (pybop.Model): The model class to be benchmarked.\n            parameter_set (str): The name of the parameter set to be used.\n        \"\"\"\n        # Set random seed\n        set_random_seed()\n    \n        # Create model instance\n        self.model = model(parameter_set=pybop.ParameterSet.pybamm(parameter_set))\n    \n        # Define fitting parameters\n        parameters = pybop.Parameters(\n            pybop.Parameter(\n                \"Current function [A]\",\n                prior=pybop.Gaussian(0.4, 0.02),\n                bounds=[0.2, 0.7],\n                initial_value=0.4,\n            )\n        )\n    \n        # Generate synthetic data\n        sigma = 0.001\n        self.t_eval = np.arange(0, 900, 2)\n        self.init_state = {\"Initial SoC\": 0.5}\n        values = self.model.predict(t_eval=self.t_eval, initial_state=self.init_state)\n        corrupt_values = values[\"Voltage [V]\"].data + np.random.normal(\n            0, sigma, len(self.t_eval)\n        )\n    \n        self.inputs = {\n            \"Current function [A]\": 0.4,\n        }\n    \n        # Create dataset\n        dataset = pybop.Dataset(\n            {\n                \"Time [s]\": self.t_eval,\n                \"Current function [A]\": values[\"Current [A]\"].data,\n                \"Voltage [V]\": corrupt_values,\n            }\n        )\n    \n        # Create fitting problem\n        self.problem = pybop.FittingProblem(\n            model=self.model, dataset=dataset, parameters=parameters\n        )", "min_run_count": 2, "name": "benchmark_model.BenchmarkModel.time_model_simulateS1", "number": 0, "param_names": ["model", "parameter_set"], "params": [["<class 'pybop.models.lithium_ion.echem.SPM'>", "<class 'pybop.models.lithium_ion.echem.SPMe'>"], ["'Chen2020'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "e6736ea769b985f62ac5f132ac58958ddbc60c2dda0517aa47a4390eb56b8a13", "warmup_time": -1}, "benchmark_optim_construction.BenchmarkOptimisationConstruction.time_cost_evaluate": {"code": "class BenchmarkOptimisationConstruction:\n    def time_cost_evaluate(self, model, parameter_set, optimiser):\n        \"\"\"\n        Benchmark the cost function evaluation.\n    \n        Args:\n            model (pybop.Model): The model class being benchmarked.\n            parameter_set (str): The name of the parameter set being used.\n            optimiser (pybop.Optimiser): The optimiser class being used.\n        \"\"\"\n        self.cost([0.63, 0.51])\n\n    def setup(self, model, parameter_set, optimiser):\n        \"\"\"\n        Set up the model, problem, and cost for optimization benchmarking.\n    \n        Args:\n            model (pybop.Model): The model class to be benchmarked.\n            parameter_set (str): The name of the parameter set to be used.\n            optimiser (pybop.Optimiser): The optimizer class to be used.\n        \"\"\"\n        # Set random seed\n        set_random_seed()\n    \n        # Create model instance\n        model_instance = model(parameter_set=pybop.ParameterSet.pybamm(parameter_set))\n    \n        # Define fitting parameters\n        parameters = pybop.Parameters(\n            pybop.Parameter(\n                \"Negative electrode active material volume fraction\",\n                prior=pybop.Gaussian(0.6, 0.02),\n                bounds=[0.375, 0.7],\n                initial_value=0.63,\n            ),\n            pybop.Parameter(\n                \"Positive electrode active material volume fraction\",\n                prior=pybop.Gaussian(0.5, 0.02),\n                bounds=[0.375, 0.625],\n                initial_value=0.51,\n            ),\n        )\n    \n        # Generate synthetic data\n        sigma = 0.001\n        t_eval = np.arange(0, 900, 2)\n        values = model_instance.predict(t_eval=t_eval)\n        corrupt_values = values[\"Voltage [V]\"].data + np.random.normal(\n            0, sigma, len(t_eval)\n        )\n    \n        # Create dataset\n        dataset = pybop.Dataset(\n            {\n                \"Time [s]\": t_eval,\n                \"Current function [A]\": values[\"Current [A]\"].data,\n                \"Voltage [V]\": corrupt_values,\n            }\n        )\n    \n        # Create fitting problem\n        problem = pybop.FittingProblem(\n            model=model_instance, dataset=dataset, parameters=parameters\n        )\n    \n        # Create cost function\n        self.cost = pybop.SumSquaredError(problem=problem)", "min_run_count": 2, "name": "benchmark_optim_construction.BenchmarkOptimisationConstruction.time_cost_evaluate", "number": 0, "param_names": ["model", "parameter_set", "optimiser"], "params": [["<class 'pybop.models.lithium_ion.echem.SPM'>", "<class 'pybop.models.lithium_ion.echem.SPMe'>"], ["'Chen2020'"], ["<class 'pybop.optimisers.pints_optimisers.CMAES'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "36dd7863148059bcfa0a52a03fc7d091242344a4833782181239033a79d482fd", "warmup_time": -1}, "benchmark_optim_construction.BenchmarkOptimisationConstruction.time_optimisation_construction": {"code": "class BenchmarkOptimisationConstruction:\n    def time_optimisation_construction(self, model, parameter_set, optimiser):\n        \"\"\"\n        Benchmark the construction of the optimization class.\n    \n        Args:\n            model (pybop.Model): The model class being benchmarked.\n            parameter_set (str): The name of the parameter set being used.\n            optimiser (pybop.Optimiser): The optimiser class being used.\n        \"\"\"\n        self.optim = pybop.Optimisation(self.cost, optimiser=optimiser)\n\n    def setup(self, model, parameter_set, optimiser):\n        \"\"\"\n        Set up the model, problem, and cost for optimization benchmarking.\n    \n        Args:\n            model (pybop.Model): The model class to be benchmarked.\n            parameter_set (str): The name of the parameter set to be used.\n            optimiser (pybop.Optimiser): The optimizer class to be used.\n        \"\"\"\n        # Set random seed\n        set_random_seed()\n    \n        # Create model instance\n        model_instance = model(parameter_set=pybop.ParameterSet.pybamm(parameter_set))\n    \n        # Define fitting parameters\n        parameters = pybop.Parameters(\n            pybop.Parameter(\n                \"Negative electrode active material volume fraction\",\n                prior=pybop.Gaussian(0.6, 0.02),\n                bounds=[0.375, 0.7],\n                initial_value=0.63,\n            ),\n            pybop.Parameter(\n                \"Positive electrode active material volume fraction\",\n                prior=pybop.Gaussian(0.5, 0.02),\n                bounds=[0.375, 0.625],\n                initial_value=0.51,\n            ),\n        )\n    \n        # Generate synthetic data\n        sigma = 0.001\n        t_eval = np.arange(0, 900, 2)\n        values = model_instance.predict(t_eval=t_eval)\n        corrupt_values = values[\"Voltage [V]\"].data + np.random.normal(\n            0, sigma, len(t_eval)\n        )\n    \n        # Create dataset\n        dataset = pybop.Dataset(\n            {\n                \"Time [s]\": t_eval,\n                \"Current function [A]\": values[\"Current [A]\"].data,\n                \"Voltage [V]\": corrupt_values,\n            }\n        )\n    \n        # Create fitting problem\n        problem = pybop.FittingProblem(\n            model=model_instance, dataset=dataset, parameters=parameters\n        )\n    \n        # Create cost function\n        self.cost = pybop.SumSquaredError(problem=problem)", "min_run_count": 2, "name": "benchmark_optim_construction.BenchmarkOptimisationConstruction.time_optimisation_construction", "number": 0, "param_names": ["model", "parameter_set", "optimiser"], "params": [["<class 'pybop.models.lithium_ion.echem.SPM'>", "<class 'pybop.models.lithium_ion.echem.SPMe'>"], ["'Chen2020'"], ["<class 'pybop.optimisers.pints_optimisers.CMAES'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "604fd991f1b6248286dbf356c2ea0b8a8f586b1e3158f7c28b3acf27ea85de9e", "warmup_time": -1}, "benchmark_parameterisation.BenchmarkParameterisation.time_optimiser_ask": {"code": "class BenchmarkParameterisation:\n    def time_optimiser_ask(self, model, parameter_set, optimiser):\n        \"\"\"\n        Benchmark the optimizer's ask method.\n    \n        Args:\n            model (pybop.Model): The model class being benchmarked (unused).\n            parameter_set (str): The name of the parameter set being used (unused).\n            optimiser (pybop.Optimiser): The optimizer class being used.\n        \"\"\"\n        if optimiser not in [pybop.SciPyMinimize, pybop.SciPyDifferentialEvolution]:\n            self.optim.pints_optimiser.ask()\n\n    def setup(self, model, parameter_set, optimiser):\n        \"\"\"\n        Set up the parameterization problem for benchmarking.\n    \n        Args:\n            model (pybop.Model): The model class to be benchmarked.\n            parameter_set (str): The name of the parameter set to be used.\n            optimiser (pybop.Optimiser): The optimiser class to be used.\n        \"\"\"\n        # Set random seed\n        set_random_seed()\n    \n        # Create model instance\n        params = pybop.ParameterSet.pybamm(parameter_set)\n        params.update(\n            {\n                \"Negative electrode active material volume fraction\": 0.63,\n                \"Positive electrode active material volume fraction\": 0.51,\n            }\n        )\n        model_instance = model(parameter_set=params)\n    \n        # Define fitting parameters\n        parameters = pybop.Parameters(\n            pybop.Parameter(\n                \"Negative electrode active material volume fraction\",\n                prior=pybop.Gaussian(0.55, 0.03),\n                bounds=[0.375, 0.7],\n            ),\n            pybop.Parameter(\n                \"Positive electrode active material volume fraction\",\n                prior=pybop.Gaussian(0.55, 0.03),\n                bounds=[0.375, 0.7],\n            ),\n        )\n    \n        # Generate synthetic data\n        sigma = 0.003\n        t_eval = np.arange(0, 900, 2)\n        values = model_instance.predict(t_eval=t_eval)\n        corrupt_values = values[\"Voltage [V]\"].data + np.random.normal(\n            0, sigma, len(t_eval)\n        )\n    \n        # Create dataset\n        dataset = pybop.Dataset(\n            {\n                \"Time [s]\": t_eval,\n                \"Current function [A]\": values[\"Current [A]\"].data,\n                \"Voltage [V]\": corrupt_values,\n            }\n        )\n    \n        # Create fitting problem\n        problem = pybop.FittingProblem(model_instance, parameters, dataset)\n    \n        # Create cost function\n        cost = pybop.SumSquaredError(problem=problem)\n    \n        # Create optimization instance and set options for consistent benchmarking\n        if optimiser in [pybop.GradientDescent]:\n            self.optim = pybop.Optimisation(\n                cost,\n                optimiser=optimiser,\n                max_iterations=250,\n                max_unchanged_iterations=25,\n                threshold=1e-5,\n                min_iterations=2,\n                learning_rate=0.008,  # Compromise between stability & performance\n            )\n        else:\n            self.optim = pybop.Optimisation(\n                cost,\n                optimiser=optimiser,\n                max_iterations=250,\n                max_unchanged_iterations=25,\n                threshold=1e-5,\n                min_iterations=2,\n            )", "min_run_count": 2, "name": "benchmark_parameterisation.BenchmarkParameterisation.time_optimiser_ask", "number": 0, "param_names": ["model", "parameter_set", "optimiser"], "params": [["<class 'pybop.models.lithium_ion.echem.SPM'>", "<class 'pybop.models.lithium_ion.echem.SPMe'>"], ["'Chen2020'"], ["<class 'pybop.optimisers.scipy_optimisers.SciPyMinimize'>", "<class 'pybop.optimisers.scipy_optimisers.SciPyDifferentialEvolution'>", "<class 'pybop.optimisers.pints_optimisers.AdamW'>", "<class 'pybop.optimisers.pints_optimisers.CMAES'>", "<class 'pybop.optimisers.pints_optimisers.GradientDescent'>", "<class 'pybop.optimisers.pints_optimisers.IRPropMin'>", "<class 'pybop.optimisers.pints_optimisers.PSO'>", "<class 'pybop.optimisers.pints_optimisers.SNES'>", "<class 'pybop.optimisers.pints_optimisers.XNES'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "e072526e934d1829ae2c73917a85f2dfac5b8e6b921a952c05490ccc8526ac91", "warmup_time": -1}, "benchmark_parameterisation.BenchmarkParameterisation.time_parameterisation": {"code": "class BenchmarkParameterisation:\n    def time_parameterisation(self, model, parameter_set, optimiser):\n        \"\"\"\n        Benchmark the parameterization process. Optimiser options are left at high values\n        to ensure the threshold is met and the optimisation process is completed.\n    \n        Args:\n            model (pybop.Model): The model class being benchmarked (unused).\n            parameter_set (str): The name of the parameter set being used (unused).\n            optimiser (pybop.Optimiser): The optimiser class being used (unused).\n        \"\"\"\n        self.optim.run()\n\n    def setup(self, model, parameter_set, optimiser):\n        \"\"\"\n        Set up the parameterization problem for benchmarking.\n    \n        Args:\n            model (pybop.Model): The model class to be benchmarked.\n            parameter_set (str): The name of the parameter set to be used.\n            optimiser (pybop.Optimiser): The optimiser class to be used.\n        \"\"\"\n        # Set random seed\n        set_random_seed()\n    \n        # Create model instance\n        params = pybop.ParameterSet.pybamm(parameter_set)\n        params.update(\n            {\n                \"Negative electrode active material volume fraction\": 0.63,\n                \"Positive electrode active material volume fraction\": 0.51,\n            }\n        )\n        model_instance = model(parameter_set=params)\n    \n        # Define fitting parameters\n        parameters = pybop.Parameters(\n            pybop.Parameter(\n                \"Negative electrode active material volume fraction\",\n                prior=pybop.Gaussian(0.55, 0.03),\n                bounds=[0.375, 0.7],\n            ),\n            pybop.Parameter(\n                \"Positive electrode active material volume fraction\",\n                prior=pybop.Gaussian(0.55, 0.03),\n                bounds=[0.375, 0.7],\n            ),\n        )\n    \n        # Generate synthetic data\n        sigma = 0.003\n        t_eval = np.arange(0, 900, 2)\n        values = model_instance.predict(t_eval=t_eval)\n        corrupt_values = values[\"Voltage [V]\"].data + np.random.normal(\n            0, sigma, len(t_eval)\n        )\n    \n        # Create dataset\n        dataset = pybop.Dataset(\n            {\n                \"Time [s]\": t_eval,\n                \"Current function [A]\": values[\"Current [A]\"].data,\n                \"Voltage [V]\": corrupt_values,\n            }\n        )\n    \n        # Create fitting problem\n        problem = pybop.FittingProblem(model_instance, parameters, dataset)\n    \n        # Create cost function\n        cost = pybop.SumSquaredError(problem=problem)\n    \n        # Create optimization instance and set options for consistent benchmarking\n        if optimiser in [pybop.GradientDescent]:\n            self.optim = pybop.Optimisation(\n                cost,\n                optimiser=optimiser,\n                max_iterations=250,\n                max_unchanged_iterations=25,\n                threshold=1e-5,\n                min_iterations=2,\n                learning_rate=0.008,  # Compromise between stability & performance\n            )\n        else:\n            self.optim = pybop.Optimisation(\n                cost,\n                optimiser=optimiser,\n                max_iterations=250,\n                max_unchanged_iterations=25,\n                threshold=1e-5,\n                min_iterations=2,\n            )", "min_run_count": 2, "name": "benchmark_parameterisation.BenchmarkParameterisation.time_parameterisation", "number": 0, "param_names": ["model", "parameter_set", "optimiser"], "params": [["<class 'pybop.models.lithium_ion.echem.SPM'>", "<class 'pybop.models.lithium_ion.echem.SPMe'>"], ["'Chen2020'"], ["<class 'pybop.optimisers.scipy_optimisers.SciPyMinimize'>", "<class 'pybop.optimisers.scipy_optimisers.SciPyDifferentialEvolution'>", "<class 'pybop.optimisers.pints_optimisers.AdamW'>", "<class 'pybop.optimisers.pints_optimisers.CMAES'>", "<class 'pybop.optimisers.pints_optimisers.GradientDescent'>", "<class 'pybop.optimisers.pints_optimisers.IRPropMin'>", "<class 'pybop.optimisers.pints_optimisers.PSO'>", "<class 'pybop.optimisers.pints_optimisers.SNES'>", "<class 'pybop.optimisers.pints_optimisers.XNES'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "21afc4b73028303679eb444dd141fa868b50f068da343df1d924ea5df9f4e744", "warmup_time": -1}, "benchmark_track_parameterisation.BenchmarkTrackParameterisation.track_x1": {"code": "class BenchmarkTrackParameterisation:\n    def track_x1(self, model, parameter_set, optimiser):\n        return self.x[0]\n\n    def setup(self, model, parameter_set, optimiser):\n        \"\"\"\n        Set up the parameterization problem for benchmarking.\n    \n        Args:\n            model (pybop.Model): The model class to be benchmarked.\n            parameter_set (str): The name of the parameter set to be used.\n            optimiser (pybop.Optimiser): The optimizer class to be used.\n        \"\"\"\n        # Set random seed\n        set_random_seed()\n    \n        # Create model instance\n        params = pybop.ParameterSet.pybamm(parameter_set)\n        params.update(\n            {\n                \"Negative electrode active material volume fraction\": 0.63,\n                \"Positive electrode active material volume fraction\": 0.51,\n            }\n        )\n        model_instance = model(parameter_set=params)\n    \n        # Define fitting parameters\n        parameters = pybop.Parameters(\n            pybop.Parameter(\n                \"Negative electrode active material volume fraction\",\n                prior=pybop.Gaussian(0.55, 0.03),\n                bounds=[0.375, 0.7],\n            ),\n            pybop.Parameter(\n                \"Positive electrode active material volume fraction\",\n                prior=pybop.Gaussian(0.55, 0.03),\n                bounds=[0.375, 0.7],\n            ),\n        )\n    \n        # Generate synthetic data\n        sigma = 0.003\n        t_eval = np.arange(0, 900, 2)\n        values = model_instance.predict(t_eval=t_eval)\n        corrupt_values = values[\"Voltage [V]\"].data + np.random.normal(\n            0, sigma, len(t_eval)\n        )\n    \n        # Create dataset\n        dataset = pybop.Dataset(\n            {\n                \"Time [s]\": t_eval,\n                \"Current function [A]\": values[\"Current [A]\"].data,\n                \"Voltage [V]\": corrupt_values,\n            }\n        )\n    \n        # Create fitting problem\n        problem = pybop.FittingProblem(model_instance, parameters, dataset)\n    \n        # Create cost function\n        cost = pybop.SumSquaredError(problem=problem)\n    \n        # Create optimization instance and set options for consistent benchmarking\n        if optimiser in [pybop.GradientDescent]:\n            self.optim = pybop.Optimisation(\n                cost,\n                optimiser=optimiser,\n                max_iterations=250,\n                max_unchanged_iterations=25,\n                threshold=1e-5,\n                min_iterations=2,\n                learning_rate=0.008,  # Compromise between stability & performance\n            )\n        else:\n            self.optim = pybop.Optimisation(\n                cost,\n                optimiser=optimiser,\n                max_iterations=250,\n                max_unchanged_iterations=25,\n                threshold=1e-5,\n                min_iterations=2,\n            )\n    \n        # Track output results\n        self.x = self.results_tracking(model, parameter_set, optimiser)", "name": "benchmark_track_parameterisation.BenchmarkTrackParameterisation.track_x1", "param_names": ["model", "parameter_set", "optimiser"], "params": [["<class 'pybop.models.lithium_ion.echem.SPM'>", "<class 'pybop.models.lithium_ion.echem.SPMe'>"], ["'Chen2020'"], ["<class 'pybop.optimisers.scipy_optimisers.SciPyMinimize'>", "<class 'pybop.optimisers.scipy_optimisers.SciPyDifferentialEvolution'>", "<class 'pybop.optimisers.pints_optimisers.AdamW'>", "<class 'pybop.optimisers.pints_optimisers.CMAES'>", "<class 'pybop.optimisers.pints_optimisers.GradientDescent'>", "<class 'pybop.optimisers.pints_optimisers.IRPropMin'>", "<class 'pybop.optimisers.pints_optimisers.PSO'>", "<class 'pybop.optimisers.pints_optimisers.SNES'>", "<class 'pybop.optimisers.pints_optimisers.XNES'>"]], "type": "track", "unit": "unit", "version": "410a7efa8c9e84890782035e3c281b3e3e15ce460ed4bd8657b2c9c621449806"}, "benchmark_track_parameterisation.BenchmarkTrackParameterisation.track_x2": {"code": "class BenchmarkTrackParameterisation:\n    def track_x2(self, model, parameter_set, optimiser):\n        return self.x[1]\n\n    def setup(self, model, parameter_set, optimiser):\n        \"\"\"\n        Set up the parameterization problem for benchmarking.\n    \n        Args:\n            model (pybop.Model): The model class to be benchmarked.\n            parameter_set (str): The name of the parameter set to be used.\n            optimiser (pybop.Optimiser): The optimizer class to be used.\n        \"\"\"\n        # Set random seed\n        set_random_seed()\n    \n        # Create model instance\n        params = pybop.ParameterSet.pybamm(parameter_set)\n        params.update(\n            {\n                \"Negative electrode active material volume fraction\": 0.63,\n                \"Positive electrode active material volume fraction\": 0.51,\n            }\n        )\n        model_instance = model(parameter_set=params)\n    \n        # Define fitting parameters\n        parameters = pybop.Parameters(\n            pybop.Parameter(\n                \"Negative electrode active material volume fraction\",\n                prior=pybop.Gaussian(0.55, 0.03),\n                bounds=[0.375, 0.7],\n            ),\n            pybop.Parameter(\n                \"Positive electrode active material volume fraction\",\n                prior=pybop.Gaussian(0.55, 0.03),\n                bounds=[0.375, 0.7],\n            ),\n        )\n    \n        # Generate synthetic data\n        sigma = 0.003\n        t_eval = np.arange(0, 900, 2)\n        values = model_instance.predict(t_eval=t_eval)\n        corrupt_values = values[\"Voltage [V]\"].data + np.random.normal(\n            0, sigma, len(t_eval)\n        )\n    \n        # Create dataset\n        dataset = pybop.Dataset(\n            {\n                \"Time [s]\": t_eval,\n                \"Current function [A]\": values[\"Current [A]\"].data,\n                \"Voltage [V]\": corrupt_values,\n            }\n        )\n    \n        # Create fitting problem\n        problem = pybop.FittingProblem(model_instance, parameters, dataset)\n    \n        # Create cost function\n        cost = pybop.SumSquaredError(problem=problem)\n    \n        # Create optimization instance and set options for consistent benchmarking\n        if optimiser in [pybop.GradientDescent]:\n            self.optim = pybop.Optimisation(\n                cost,\n                optimiser=optimiser,\n                max_iterations=250,\n                max_unchanged_iterations=25,\n                threshold=1e-5,\n                min_iterations=2,\n                learning_rate=0.008,  # Compromise between stability & performance\n            )\n        else:\n            self.optim = pybop.Optimisation(\n                cost,\n                optimiser=optimiser,\n                max_iterations=250,\n                max_unchanged_iterations=25,\n                threshold=1e-5,\n                min_iterations=2,\n            )\n    \n        # Track output results\n        self.x = self.results_tracking(model, parameter_set, optimiser)", "name": "benchmark_track_parameterisation.BenchmarkTrackParameterisation.track_x2", "param_names": ["model", "parameter_set", "optimiser"], "params": [["<class 'pybop.models.lithium_ion.echem.SPM'>", "<class 'pybop.models.lithium_ion.echem.SPMe'>"], ["'Chen2020'"], ["<class 'pybop.optimisers.scipy_optimisers.SciPyMinimize'>", "<class 'pybop.optimisers.scipy_optimisers.SciPyDifferentialEvolution'>", "<class 'pybop.optimisers.pints_optimisers.AdamW'>", "<class 'pybop.optimisers.pints_optimisers.CMAES'>", "<class 'pybop.optimisers.pints_optimisers.GradientDescent'>", "<class 'pybop.optimisers.pints_optimisers.IRPropMin'>", "<class 'pybop.optimisers.pints_optimisers.PSO'>", "<class 'pybop.optimisers.pints_optimisers.SNES'>", "<class 'pybop.optimisers.pints_optimisers.XNES'>"]], "type": "track", "unit": "unit", "version": "44b8e89b0bba0d5815b85bfd88d86570b6c84a077b8f8e07e250f2fc1c89a1ac"}}, "machines": {"SelfHostedRunner": {"machine": "SelfHostedRunner", "version": 1}}, "tags": {"v23.11": 325, "v23.12": 542, "v23.12rc0": 534, "v24.3": 1079, "v24.3.1": 1731, "v24.6": 1912, "v24.6.1": 2121, "v24.9.0": 2590, "v24.9.1": 2637}, "pages": [["", "Grid view", "Display as a agrid"], ["summarylist", "List view", "Display as a list"], ["regressions", "Show regressions", "Display information about recent regressions"]]}