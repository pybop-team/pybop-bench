{"project": "PyBOP", "project_url": "https://github.com/pybop-team/pybop", "show_commit_url": "#", "hash_length": 8, "revision_to_hash": {"325": "6e5c00781643987c467654379d2352df94317055", "534": "760ceb84eeb88376740a735b000331d7e2956674", "542": "9e9c067c981febfc1ad7bc6771566bbfc65d4339", "982": "ebc7b628b10c4835f8e842158b44f4622f30d6d2", "983": "aa9a3951b1e24a9f2a1100a1b63e990db8e093dc"}, "revision_to_date": {"325": 1700495475000, "534": 1702977995000, "542": 1703062685000, "982": 1710526427000, "983": 1710583883000}, "params": {"machine": ["SelfHostedRunner"], "python": ["3.12"], "pybamm": [""], "numpy": [""], "scipy": [""], "pints": [""], "branch": ["179-add-airspeed-velocity-for-automated-benchmarking"]}, "graph_param_list": [{"machine": "SelfHostedRunner", "python": "3.12", "pybamm": "", "numpy": "", "scipy": "", "pints": "", "branch": "179-add-airspeed-velocity-for-automated-benchmarking"}], "benchmarks": {"benchmark_model.BenchmarkModel.time_model_predict": {"code": "class BenchmarkModel:\n    def time_model_predict(self, model, parameter_set):\n        \"\"\"\n        Benchmark the predict method of the model.\n    \n        Args:\n            model (pybop.Model): The model class being benchmarked.\n            parameter_set (str): The name of the parameter set being used.\n        \"\"\"\n        self.model.predict(inputs=self.inputs, t_eval=self.t_eval)\n\n    def setup(self, model, parameter_set):\n        \"\"\"\n        Setup the model and problem for predict and simulate benchmarks.\n    \n        Args:\n            model (pybop.Model): The model class to be benchmarked.\n            parameter_set (str): The name of the parameter set to be used.\n        \"\"\"\n        # Create model instance\n        self.model = model(parameter_set=pybop.ParameterSet.pybamm(parameter_set))\n    \n        # Define fitting parameters\n        parameters = [\n            pybop.Parameter(\n                \"Current function [A]\",\n                prior=pybop.Gaussian(0.4, 0.02),\n                bounds=[0.2, 0.7],\n                initial_value=0.4,\n            )\n        ]\n    \n        # Generate synthetic data\n        sigma = 0.001\n        self.t_eval = np.arange(0, 900, 2)\n        values = self.model.predict(t_eval=self.t_eval)\n        corrupt_values = values[\"Voltage [V]\"].data + np.random.normal(\n            0, sigma, len(self.t_eval)\n        )\n    \n        self.inputs = {\n            \"Current function [A]\": 0.4,\n        }\n    \n        # Create dataset\n        dataset = pybop.Dataset(\n            {\n                \"Time [s]\": self.t_eval,\n                \"Current function [A]\": values[\"Current [A]\"].data,\n                \"Voltage [V]\": corrupt_values,\n            }\n        )\n    \n        # Create fitting problem\n        self.problem = pybop.FittingProblem(\n            model=self.model, dataset=dataset, parameters=parameters, init_soc=0.5\n        )", "min_run_count": 2, "name": "benchmark_model.BenchmarkModel.time_model_predict", "number": 0, "param_names": ["model", "parameter_set"], "params": [["<class 'pybop.models.lithium_ion.echem.SPM'>", "<class 'pybop.models.lithium_ion.echem.SPMe'>"], ["'Chen2020'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "fdff21445295f938744e21f761a10c770c0bade7145ec8da94aa1e5708b80f88", "warmup_time": -1}, "benchmark_model.BenchmarkModel.time_model_simulate": {"code": "class BenchmarkModel:\n    def time_model_simulate(self, model, parameter_set):\n        \"\"\"\n        Benchmark the simulate method of the model.\n    \n        Args:\n            model (pybop.Model): The model class being benchmarked.\n            parameter_set (str): The name of the parameter set being used.\n        \"\"\"\n        self.problem._model.simulate(inputs=self.inputs, t_eval=self.t_eval)\n\n    def setup(self, model, parameter_set):\n        \"\"\"\n        Setup the model and problem for predict and simulate benchmarks.\n    \n        Args:\n            model (pybop.Model): The model class to be benchmarked.\n            parameter_set (str): The name of the parameter set to be used.\n        \"\"\"\n        # Create model instance\n        self.model = model(parameter_set=pybop.ParameterSet.pybamm(parameter_set))\n    \n        # Define fitting parameters\n        parameters = [\n            pybop.Parameter(\n                \"Current function [A]\",\n                prior=pybop.Gaussian(0.4, 0.02),\n                bounds=[0.2, 0.7],\n                initial_value=0.4,\n            )\n        ]\n    \n        # Generate synthetic data\n        sigma = 0.001\n        self.t_eval = np.arange(0, 900, 2)\n        values = self.model.predict(t_eval=self.t_eval)\n        corrupt_values = values[\"Voltage [V]\"].data + np.random.normal(\n            0, sigma, len(self.t_eval)\n        )\n    \n        self.inputs = {\n            \"Current function [A]\": 0.4,\n        }\n    \n        # Create dataset\n        dataset = pybop.Dataset(\n            {\n                \"Time [s]\": self.t_eval,\n                \"Current function [A]\": values[\"Current [A]\"].data,\n                \"Voltage [V]\": corrupt_values,\n            }\n        )\n    \n        # Create fitting problem\n        self.problem = pybop.FittingProblem(\n            model=self.model, dataset=dataset, parameters=parameters, init_soc=0.5\n        )", "min_run_count": 2, "name": "benchmark_model.BenchmarkModel.time_model_simulate", "number": 0, "param_names": ["model", "parameter_set"], "params": [["<class 'pybop.models.lithium_ion.echem.SPM'>", "<class 'pybop.models.lithium_ion.echem.SPMe'>"], ["'Chen2020'"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "8eef31cbede8af5e86f4f649a9b8f2a95f2613394a680e501d23102e439bdcac", "warmup_time": -1}, "benchmark_optim_construction.BenchmarkOptimisationConstruction.time_cost": {"code": "class BenchmarkOptimisationConstruction:\n    def time_cost(self, model, parameter_set, optimiser):\n        \"\"\"\n        Benchmark the cost function evaluation.\n    \n        Args:\n            model (pybop.Model): The model class being benchmarked.\n            parameter_set (str): The name of the parameter set being used.\n            optimiser (pybop.Optimiser): The optimizer class being used.\n        \"\"\"\n        self.cost([0.63, 0.51])\n\n    def setup(self, model, parameter_set, optimiser):\n        \"\"\"\n        Set up the model, problem, and cost for optimization benchmarking.\n    \n        Args:\n            model (pybop.Model): The model class to be benchmarked.\n            parameter_set (str): The name of the parameter set to be used.\n            optimiser (pybop.Optimiser): The optimizer class to be used.\n        \"\"\"\n        # Create model instance\n        model_instance = model(parameter_set=pybop.ParameterSet.pybamm(parameter_set))\n    \n        # Define fitting parameters\n        parameters = [\n            pybop.Parameter(\n                \"Negative electrode active material volume fraction\",\n                prior=pybop.Gaussian(0.6, 0.02),\n                bounds=[0.375, 0.7],\n                initial_value=0.63,\n            ),\n            pybop.Parameter(\n                \"Positive electrode active material volume fraction\",\n                prior=pybop.Gaussian(0.5, 0.02),\n                bounds=[0.375, 0.625],\n                initial_value=0.51,\n            ),\n        ]\n    \n        # Generate synthetic data\n        sigma = 0.001\n        t_eval = np.arange(0, 900, 2)\n        values = model_instance.predict(t_eval=t_eval)\n        corrupt_values = values[\"Voltage [V]\"].data + np.random.normal(\n            0, sigma, len(t_eval)\n        )\n    \n        # Create dataset\n        dataset = pybop.Dataset(\n            {\n                \"Time [s]\": t_eval,\n                \"Current function [A]\": values[\"Current [A]\"].data,\n                \"Voltage [V]\": corrupt_values,\n            }\n        )\n    \n        # Create fitting problem\n        problem = pybop.FittingProblem(\n            model=model_instance, dataset=dataset, parameters=parameters, init_soc=0.5\n        )\n    \n        # Create cost function\n        self.cost = pybop.SumSquaredError(problem=problem)", "min_run_count": 2, "name": "benchmark_optim_construction.BenchmarkOptimisationConstruction.time_cost", "number": 0, "param_names": ["model", "parameter_set", "optimiser"], "params": [["<class 'pybop.models.lithium_ion.echem.SPM'>", "<class 'pybop.models.lithium_ion.echem.SPMe'>"], ["'Chen2020'"], ["<class 'pybop.optimisers.pints_optimisers.CMAES'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "4164ba7c727a16e980ddaca00899de695773f525e177ea4f8138d69da8d1cb2b", "warmup_time": -1}, "benchmark_optim_construction.BenchmarkOptimisationConstruction.time_optimisation_construction": {"code": "class BenchmarkOptimisationConstruction:\n    def time_optimisation_construction(self, model, parameter_set, optimiser):\n        \"\"\"\n        Benchmark the construction of the optimization class.\n    \n        Args:\n            model (pybop.Model): The model class being benchmarked.\n            parameter_set (str): The name of the parameter set being used.\n            optimiser (pybop.Optimiser): The optimizer class being used.\n        \"\"\"\n        self.optim = pybop.Optimisation(self.cost, optimiser=optimiser)\n\n    def setup(self, model, parameter_set, optimiser):\n        \"\"\"\n        Set up the model, problem, and cost for optimization benchmarking.\n    \n        Args:\n            model (pybop.Model): The model class to be benchmarked.\n            parameter_set (str): The name of the parameter set to be used.\n            optimiser (pybop.Optimiser): The optimizer class to be used.\n        \"\"\"\n        # Create model instance\n        model_instance = model(parameter_set=pybop.ParameterSet.pybamm(parameter_set))\n    \n        # Define fitting parameters\n        parameters = [\n            pybop.Parameter(\n                \"Negative electrode active material volume fraction\",\n                prior=pybop.Gaussian(0.6, 0.02),\n                bounds=[0.375, 0.7],\n                initial_value=0.63,\n            ),\n            pybop.Parameter(\n                \"Positive electrode active material volume fraction\",\n                prior=pybop.Gaussian(0.5, 0.02),\n                bounds=[0.375, 0.625],\n                initial_value=0.51,\n            ),\n        ]\n    \n        # Generate synthetic data\n        sigma = 0.001\n        t_eval = np.arange(0, 900, 2)\n        values = model_instance.predict(t_eval=t_eval)\n        corrupt_values = values[\"Voltage [V]\"].data + np.random.normal(\n            0, sigma, len(t_eval)\n        )\n    \n        # Create dataset\n        dataset = pybop.Dataset(\n            {\n                \"Time [s]\": t_eval,\n                \"Current function [A]\": values[\"Current [A]\"].data,\n                \"Voltage [V]\": corrupt_values,\n            }\n        )\n    \n        # Create fitting problem\n        problem = pybop.FittingProblem(\n            model=model_instance, dataset=dataset, parameters=parameters, init_soc=0.5\n        )\n    \n        # Create cost function\n        self.cost = pybop.SumSquaredError(problem=problem)", "min_run_count": 2, "name": "benchmark_optim_construction.BenchmarkOptimisationConstruction.time_optimisation_construction", "number": 0, "param_names": ["model", "parameter_set", "optimiser"], "params": [["<class 'pybop.models.lithium_ion.echem.SPM'>", "<class 'pybop.models.lithium_ion.echem.SPMe'>"], ["'Chen2020'"], ["<class 'pybop.optimisers.pints_optimisers.CMAES'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "d342b685fdd728d459de3fe2fc75f59ad5f5561cbbc5647607bc03c0ae1ef9d7", "warmup_time": -1}, "parameterisation_benchmark.ParameterisationBenchmark.time_optimiser_ask": {"code": "class ParameterisationBenchmark:\n    def time_optimiser_ask(self, _model, _parameter_set, optimiser):\n        \"\"\"\n        Benchmark the optimizer's ask method.\n    \n        Args:\n            _model (pybop.Model): The model class being benchmarked (unused).\n            _parameter_set (str): The name of the parameter set being used (unused).\n            optimiser (pybop.Optimiser): The optimizer class being used.\n        \"\"\"\n        if optimiser not in [pybop.SciPyMinimize, pybop.SciPyDifferentialEvolution]:\n            self.optim.optimiser.ask()\n\n    def setup(self, model, parameter_set, optimiser):\n        \"\"\"\n        Set up the parameterization problem for benchmarking.\n    \n        Args:\n            model (pybop.Model): The model class to be benchmarked.\n            parameter_set (str): The name of the parameter set to be used.\n            optimiser (pybop.Optimiser): The optimizer class to be used.\n        \"\"\"\n        # Create model instance\n        model_instance = model(parameter_set=pybop.ParameterSet.pybamm(parameter_set))\n    \n        # Define fitting parameters\n        parameters = [\n            pybop.Parameter(\n                \"Negative electrode active material volume fraction\",\n                prior=pybop.Gaussian(0.6, 0.03),\n                bounds=[0.375, 0.7],\n                initial_value=0.63,\n            ),\n            pybop.Parameter(\n                \"Positive electrode active material volume fraction\",\n                prior=pybop.Gaussian(0.5, 0.03),\n                bounds=[0.375, 0.625],\n                initial_value=0.51,\n            ),\n        ]\n    \n        # Generate synthetic data\n        sigma = 0.003\n        t_eval = np.arange(0, 900, 2)\n        values = model_instance.predict(t_eval=t_eval)\n        corrupt_values = values[\"Voltage [V]\"].data + np.random.normal(\n            0, sigma, len(t_eval)\n        )\n    \n        # Create dataset\n        dataset = pybop.Dataset(\n            {\n                \"Time [s]\": t_eval,\n                \"Current function [A]\": values[\"Current [A]\"].data,\n                \"Voltage [V]\": corrupt_values,\n            }\n        )\n    \n        # Create fitting problem\n        problem = pybop.FittingProblem(\n            model=model_instance, dataset=dataset, parameters=parameters, init_soc=0.5\n        )\n    \n        # Create cost function\n        cost = pybop.SumSquaredError(problem=problem)\n    \n        # Create optimization instance\n        self.optim = pybop.Optimisation(cost, optimiser=optimiser)", "min_run_count": 2, "name": "parameterisation_benchmark.ParameterisationBenchmark.time_optimiser_ask", "number": 0, "param_names": ["model", "parameter_set", "optimiser"], "params": [["<class 'pybop.models.lithium_ion.echem.SPM'>", "<class 'pybop.models.lithium_ion.echem.SPMe'>"], ["'Chen2020'"], ["<class 'pybop.optimisers.scipy_optimisers.SciPyMinimize'>", "<class 'pybop.optimisers.scipy_optimisers.SciPyDifferentialEvolution'>", "<class 'pybop.optimisers.pints_optimisers.Adam'>", "<class 'pybop.optimisers.pints_optimisers.CMAES'>", "<class 'pybop.optimisers.pints_optimisers.GradientDescent'>", "<class 'pybop.optimisers.pints_optimisers.IRPropMin'>", "<class 'pybop.optimisers.pints_optimisers.PSO'>", "<class 'pybop.optimisers.pints_optimisers.SNES'>", "<class 'pybop.optimisers.pints_optimisers.XNES'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "8f717bb142657f5c29cd2c53e6eb24fe9ed7ed76eae1e0707e085a3884afe321", "warmup_time": -1}, "parameterisation_benchmark.ParameterisationBenchmark.time_parameterisation": {"code": "class ParameterisationBenchmark:\n    def time_parameterisation(self, _model, _parameter_set, _optimiser):\n        \"\"\"\n        Benchmark the parameterization process.\n    \n        Args:\n            _model (pybop.Model): The model class being benchmarked (unused).\n            _parameter_set (str): The name of the parameter set being used (unused).\n            _optimiser (pybop.Optimiser): The optimizer class being used (unused).\n        \"\"\"\n        self.optim.run()\n\n    def setup(self, model, parameter_set, optimiser):\n        \"\"\"\n        Set up the parameterization problem for benchmarking.\n    \n        Args:\n            model (pybop.Model): The model class to be benchmarked.\n            parameter_set (str): The name of the parameter set to be used.\n            optimiser (pybop.Optimiser): The optimizer class to be used.\n        \"\"\"\n        # Create model instance\n        model_instance = model(parameter_set=pybop.ParameterSet.pybamm(parameter_set))\n    \n        # Define fitting parameters\n        parameters = [\n            pybop.Parameter(\n                \"Negative electrode active material volume fraction\",\n                prior=pybop.Gaussian(0.6, 0.03),\n                bounds=[0.375, 0.7],\n                initial_value=0.63,\n            ),\n            pybop.Parameter(\n                \"Positive electrode active material volume fraction\",\n                prior=pybop.Gaussian(0.5, 0.03),\n                bounds=[0.375, 0.625],\n                initial_value=0.51,\n            ),\n        ]\n    \n        # Generate synthetic data\n        sigma = 0.003\n        t_eval = np.arange(0, 900, 2)\n        values = model_instance.predict(t_eval=t_eval)\n        corrupt_values = values[\"Voltage [V]\"].data + np.random.normal(\n            0, sigma, len(t_eval)\n        )\n    \n        # Create dataset\n        dataset = pybop.Dataset(\n            {\n                \"Time [s]\": t_eval,\n                \"Current function [A]\": values[\"Current [A]\"].data,\n                \"Voltage [V]\": corrupt_values,\n            }\n        )\n    \n        # Create fitting problem\n        problem = pybop.FittingProblem(\n            model=model_instance, dataset=dataset, parameters=parameters, init_soc=0.5\n        )\n    \n        # Create cost function\n        cost = pybop.SumSquaredError(problem=problem)\n    \n        # Create optimization instance\n        self.optim = pybop.Optimisation(cost, optimiser=optimiser)", "min_run_count": 2, "name": "parameterisation_benchmark.ParameterisationBenchmark.time_parameterisation", "number": 0, "param_names": ["model", "parameter_set", "optimiser"], "params": [["<class 'pybop.models.lithium_ion.echem.SPM'>", "<class 'pybop.models.lithium_ion.echem.SPMe'>"], ["'Chen2020'"], ["<class 'pybop.optimisers.scipy_optimisers.SciPyMinimize'>", "<class 'pybop.optimisers.scipy_optimisers.SciPyDifferentialEvolution'>", "<class 'pybop.optimisers.pints_optimisers.Adam'>", "<class 'pybop.optimisers.pints_optimisers.CMAES'>", "<class 'pybop.optimisers.pints_optimisers.GradientDescent'>", "<class 'pybop.optimisers.pints_optimisers.IRPropMin'>", "<class 'pybop.optimisers.pints_optimisers.PSO'>", "<class 'pybop.optimisers.pints_optimisers.SNES'>", "<class 'pybop.optimisers.pints_optimisers.XNES'>"]], "repeat": 0, "rounds": 2, "sample_time": 0.01, "type": "time", "unit": "seconds", "version": "fb4c06cd476d3e2e8989b5fddc6a6b1d202d0897b0976f236d545bbcf02d0ebc", "warmup_time": -1}}, "machines": {"SelfHostedRunner": {"machine": "SelfHostedRunner", "version": 1}}, "tags": {"v23.11": 325, "v23.12": 542, "v23.12rc0": 534}, "pages": [["", "Grid view", "Display as a agrid"], ["summarylist", "List view", "Display as a list"], ["regressions", "Show regressions", "Display information about recent regressions"]]}