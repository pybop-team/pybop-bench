{
    "benchmark_optim_construction.BenchmarkOptimisationConstruction.time_cost_evaluate": {
        "code": "class BenchmarkOptimisationConstruction:\n    def time_cost_evaluate(self, model, parameter_set, optimiser):\n        \"\"\"\n        Benchmark the cost function evaluation.\n    \n        Args:\n            model (pybop.Model): The model class being benchmarked.\n            parameter_set (str): The name of the parameter set being used.\n            optimiser (pybop.Optimiser): The optimiser class being used.\n        \"\"\"\n        self.problem([0.63, 0.51])\n\n    def setup(self, model, parameter_set, optimiser):\n        \"\"\"\n        Set up the model, problem, and cost for optimization benchmarking.\n    \n        Args:\n            model (pybop.Model): The model class to be benchmarked.\n            parameter_set (str): The name of the parameter set to be used.\n            optimiser (pybop.Optimiser): The optimiser class to be used.\n        \"\"\"\n        # Set random seed\n        set_random_seed()\n    \n        # Create parameter values\n        parameter_values = pybamm.ParameterValues(parameter_set)\n    \n        # Generate synthetic data\n        sigma = 0.001\n        t_eval = np.arange(0, 900, 2)\n        solution = pybamm.Simulation(model, parameter_values=parameter_values).solve(\n            t_eval=t_eval\n        )\n        corrupt_values = solution[\"Voltage [V]\"](t_eval) + np.random.normal(\n            0, sigma, len(t_eval)\n        )\n    \n        # Create dataset\n        dataset = pybop.Dataset(\n            {\n                \"Time [s]\": t_eval,\n                \"Current function [A]\": solution[\"Current [A]\"](t_eval),\n                \"Voltage [V]\": corrupt_values,\n            }\n        )\n    \n        # Define fitting parameters\n        parameter_values.update(\n            {\n                \"Negative electrode active material volume fraction\": pybop.Parameter(\n                    pybop.Gaussian(0.6, 0.02, truncated_at=[0.375, 0.7]),\n                    initial_value=0.63,\n                ),\n                \"Positive electrode active material volume fraction\": pybop.Parameter(\n                    pybop.Gaussian(0.5, 0.02, truncated_at=[0.375, 0.625]),\n                    initial_value=0.51,\n                ),\n            }\n        )\n    \n        # Create fitting problem\n        simulator = pybop.pybamm.Simulator(\n            model, parameter_values=parameter_values, protocol=dataset\n        )\n        cost = pybop.SumSquaredError(dataset)\n        self.problem = pybop.Problem(simulator, cost)",
        "min_run_count": 2,
        "name": "benchmark_optim_construction.BenchmarkOptimisationConstruction.time_cost_evaluate",
        "number": 0,
        "param_names": [
            "model",
            "parameter_set",
            "optimiser"
        ],
        "params": [
            [
                "<pybamm.models.full_battery_models.lithium_ion.spm.SPM object>",
                "<pybamm.models.full_battery_models.lithium_ion.spme.SPMe object>"
            ],
            [
                "'Chen2020'"
            ],
            [
                "<class 'pybop.optimisers.pints_optimisers.CMAES'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "8a8a990ee2f54ea92f2e504ef268b994349997900daa106e567a9a906a93f44a",
        "warmup_time": -1
    },
    "benchmark_optim_construction.BenchmarkOptimisationConstruction.time_optimisation_construction": {
        "code": "class BenchmarkOptimisationConstruction:\n    def time_optimisation_construction(self, model, parameter_set, optimiser):\n        \"\"\"\n        Benchmark the construction of the optimization class.\n    \n        Args:\n            model (pybop.Model): The model class being benchmarked.\n            parameter_set (str): The name of the parameter set being used.\n            optimiser (pybop.Optimiser): The optimiser class being used.\n        \"\"\"\n        self.optim = optimiser(self.problem)\n\n    def setup(self, model, parameter_set, optimiser):\n        \"\"\"\n        Set up the model, problem, and cost for optimization benchmarking.\n    \n        Args:\n            model (pybop.Model): The model class to be benchmarked.\n            parameter_set (str): The name of the parameter set to be used.\n            optimiser (pybop.Optimiser): The optimiser class to be used.\n        \"\"\"\n        # Set random seed\n        set_random_seed()\n    \n        # Create parameter values\n        parameter_values = pybamm.ParameterValues(parameter_set)\n    \n        # Generate synthetic data\n        sigma = 0.001\n        t_eval = np.arange(0, 900, 2)\n        solution = pybamm.Simulation(model, parameter_values=parameter_values).solve(\n            t_eval=t_eval\n        )\n        corrupt_values = solution[\"Voltage [V]\"](t_eval) + np.random.normal(\n            0, sigma, len(t_eval)\n        )\n    \n        # Create dataset\n        dataset = pybop.Dataset(\n            {\n                \"Time [s]\": t_eval,\n                \"Current function [A]\": solution[\"Current [A]\"](t_eval),\n                \"Voltage [V]\": corrupt_values,\n            }\n        )\n    \n        # Define fitting parameters\n        parameter_values.update(\n            {\n                \"Negative electrode active material volume fraction\": pybop.Parameter(\n                    pybop.Gaussian(0.6, 0.02, truncated_at=[0.375, 0.7]),\n                    initial_value=0.63,\n                ),\n                \"Positive electrode active material volume fraction\": pybop.Parameter(\n                    pybop.Gaussian(0.5, 0.02, truncated_at=[0.375, 0.625]),\n                    initial_value=0.51,\n                ),\n            }\n        )\n    \n        # Create fitting problem\n        simulator = pybop.pybamm.Simulator(\n            model, parameter_values=parameter_values, protocol=dataset\n        )\n        cost = pybop.SumSquaredError(dataset)\n        self.problem = pybop.Problem(simulator, cost)",
        "min_run_count": 2,
        "name": "benchmark_optim_construction.BenchmarkOptimisationConstruction.time_optimisation_construction",
        "number": 0,
        "param_names": [
            "model",
            "parameter_set",
            "optimiser"
        ],
        "params": [
            [
                "<pybamm.models.full_battery_models.lithium_ion.spm.SPM object>",
                "<pybamm.models.full_battery_models.lithium_ion.spme.SPMe object>"
            ],
            [
                "'Chen2020'"
            ],
            [
                "<class 'pybop.optimisers.pints_optimisers.CMAES'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "aff82284962b3bf3af18144be2012b80fc30fed72477a750db39e2e264c5706f",
        "warmup_time": -1
    },
    "benchmark_parameterisation.BenchmarkParameterisation.time_optimiser_ask": {
        "code": "class BenchmarkParameterisation:\n    def time_optimiser_ask(self, model, parameter_set, optimiser):\n        \"\"\"\n        Benchmark the optimizer's ask method.\n    \n        Args:\n            model (pybop.Model): The model class being benchmarked (unused).\n            parameter_set (str): The name of the parameter set being used (unused).\n            optimiser (pybop.Optimiser): The optimizer class being used.\n        \"\"\"\n        if optimiser not in [pybop.SciPyMinimize, pybop.SciPyDifferentialEvolution]:\n            self.optim.optimiser.ask()\n\n    def setup(self, model, parameter_set, optimiser):\n        \"\"\"\n        Set up the parameterization problem for benchmarking.\n    \n        Args:\n            model (pybop.Model): The model class to be benchmarked.\n            parameter_set (str): The name of the parameter set to be used.\n            optimiser (pybop.Optimiser): The optimiser class to be used.\n        \"\"\"\n        # Set random seed\n        set_random_seed()\n    \n        # Create parameter values\n        parameter_values = pybamm.ParameterValues(parameter_set)\n        parameter_values.update(\n            {\n                \"Negative electrode active material volume fraction\": 0.63,\n                \"Positive electrode active material volume fraction\": 0.51,\n            }\n        )\n    \n        # Generate synthetic data\n        sigma = 0.003\n        t_eval = np.arange(0, 900, 2)\n        solution = pybamm.Simulation(model, parameter_values=parameter_values).solve(\n            t_eval=t_eval\n        )\n        corrupt_values = solution[\"Voltage [V]\"](t_eval) + np.random.normal(\n            0, sigma, len(t_eval)\n        )\n    \n        # Create dataset\n        dataset = pybop.Dataset(\n            {\n                \"Time [s]\": t_eval,\n                \"Current function [A]\": solution[\"Current [A]\"](t_eval),\n                \"Voltage [V]\": corrupt_values,\n            }\n        )\n    \n        # Define fitting parameters\n        parameter_values.update(\n            {\n                \"Negative electrode active material volume fraction\": pybop.Parameter(\n                    pybop.Gaussian(0.55, 0.03, truncated_at=[0.375, 0.7]),\n                ),\n                \"Positive electrode active material volume fraction\": pybop.Parameter(\n                    pybop.Gaussian(0.55, 0.03, truncated_at=[0.375, 0.7]),\n                ),\n            }\n        )\n    \n        # Create fitting problem\n        simulator = pybop.pybamm.Simulator(\n            model, parameter_values=parameter_values, protocol=dataset\n        )\n        cost = pybop.SumSquaredError(dataset)\n        problem = pybop.Problem(simulator, cost)\n    \n        # Create optimiser instance and set options for consistent benchmarking\n        if optimiser is pybop.SciPyDifferentialEvolution:\n            options = pybop.SciPyDifferentialEvolutionOptions(maxiter=50)\n        elif optimiser is pybop.SciPyMinimize:\n            options = pybop.SciPyMinimizeOptions(maxiter=250)\n        else:\n            options = pybop.PintsOptions(\n                max_iterations=250,\n                max_unchanged_iterations=25,\n                threshold=1e-5,\n                min_iterations=2,\n            )\n        self.optim = optimiser(problem, options=options)",
        "min_run_count": 2,
        "name": "benchmark_parameterisation.BenchmarkParameterisation.time_optimiser_ask",
        "number": 0,
        "param_names": [
            "model",
            "parameter_set",
            "optimiser"
        ],
        "params": [
            [
                "<pybamm.models.full_battery_models.lithium_ion.spm.SPM object>",
                "<pybamm.models.full_battery_models.lithium_ion.spme.SPMe object>"
            ],
            [
                "'Chen2020'"
            ],
            [
                "<class 'pybop.optimisers.scipy_optimisers.SciPyMinimize'>",
                "<class 'pybop.optimisers.scipy_optimisers.SciPyDifferentialEvolution'>",
                "<class 'pybop.optimisers.pints_optimisers.AdamW'>",
                "<class 'pybop.optimisers.pints_optimisers.CMAES'>",
                "<class 'pybop.optimisers.pints_optimisers.GradientDescent'>",
                "<class 'pybop.optimisers.pints_optimisers.IRPropMin'>",
                "<class 'pybop.optimisers.pints_optimisers.PSO'>",
                "<class 'pybop.optimisers.pints_optimisers.SNES'>",
                "<class 'pybop.optimisers.pints_optimisers.XNES'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "a7e31b5df94dda592b0dbb0daf6b3e449d7ac4ff92e7afb84796832b8434b3d4",
        "warmup_time": -1
    },
    "benchmark_parameterisation.BenchmarkParameterisation.time_parameterisation": {
        "code": "class BenchmarkParameterisation:\n    def time_parameterisation(self, model, parameter_set, optimiser):\n        \"\"\"\n        Benchmark the parameterization process. Optimiser options are left at high values\n        to ensure the threshold is met and the optimisation process is completed.\n    \n        Args:\n            model (pybop.Model): The model class being benchmarked (unused).\n            parameter_set (str): The name of the parameter set being used (unused).\n            optimiser (pybop.Optimiser): The optimiser class being used (unused).\n        \"\"\"\n        self.optim.run()\n\n    def setup(self, model, parameter_set, optimiser):\n        \"\"\"\n        Set up the parameterization problem for benchmarking.\n    \n        Args:\n            model (pybop.Model): The model class to be benchmarked.\n            parameter_set (str): The name of the parameter set to be used.\n            optimiser (pybop.Optimiser): The optimiser class to be used.\n        \"\"\"\n        # Set random seed\n        set_random_seed()\n    \n        # Create parameter values\n        parameter_values = pybamm.ParameterValues(parameter_set)\n        parameter_values.update(\n            {\n                \"Negative electrode active material volume fraction\": 0.63,\n                \"Positive electrode active material volume fraction\": 0.51,\n            }\n        )\n    \n        # Generate synthetic data\n        sigma = 0.003\n        t_eval = np.arange(0, 900, 2)\n        solution = pybamm.Simulation(model, parameter_values=parameter_values).solve(\n            t_eval=t_eval\n        )\n        corrupt_values = solution[\"Voltage [V]\"](t_eval) + np.random.normal(\n            0, sigma, len(t_eval)\n        )\n    \n        # Create dataset\n        dataset = pybop.Dataset(\n            {\n                \"Time [s]\": t_eval,\n                \"Current function [A]\": solution[\"Current [A]\"](t_eval),\n                \"Voltage [V]\": corrupt_values,\n            }\n        )\n    \n        # Define fitting parameters\n        parameter_values.update(\n            {\n                \"Negative electrode active material volume fraction\": pybop.Parameter(\n                    pybop.Gaussian(0.55, 0.03, truncated_at=[0.375, 0.7]),\n                ),\n                \"Positive electrode active material volume fraction\": pybop.Parameter(\n                    pybop.Gaussian(0.55, 0.03, truncated_at=[0.375, 0.7]),\n                ),\n            }\n        )\n    \n        # Create fitting problem\n        simulator = pybop.pybamm.Simulator(\n            model, parameter_values=parameter_values, protocol=dataset\n        )\n        cost = pybop.SumSquaredError(dataset)\n        problem = pybop.Problem(simulator, cost)\n    \n        # Create optimiser instance and set options for consistent benchmarking\n        if optimiser is pybop.SciPyDifferentialEvolution:\n            options = pybop.SciPyDifferentialEvolutionOptions(maxiter=50)\n        elif optimiser is pybop.SciPyMinimize:\n            options = pybop.SciPyMinimizeOptions(maxiter=250)\n        else:\n            options = pybop.PintsOptions(\n                max_iterations=250,\n                max_unchanged_iterations=25,\n                threshold=1e-5,\n                min_iterations=2,\n            )\n        self.optim = optimiser(problem, options=options)",
        "min_run_count": 2,
        "name": "benchmark_parameterisation.BenchmarkParameterisation.time_parameterisation",
        "number": 0,
        "param_names": [
            "model",
            "parameter_set",
            "optimiser"
        ],
        "params": [
            [
                "<pybamm.models.full_battery_models.lithium_ion.spm.SPM object>",
                "<pybamm.models.full_battery_models.lithium_ion.spme.SPMe object>"
            ],
            [
                "'Chen2020'"
            ],
            [
                "<class 'pybop.optimisers.scipy_optimisers.SciPyMinimize'>",
                "<class 'pybop.optimisers.scipy_optimisers.SciPyDifferentialEvolution'>",
                "<class 'pybop.optimisers.pints_optimisers.AdamW'>",
                "<class 'pybop.optimisers.pints_optimisers.CMAES'>",
                "<class 'pybop.optimisers.pints_optimisers.GradientDescent'>",
                "<class 'pybop.optimisers.pints_optimisers.IRPropMin'>",
                "<class 'pybop.optimisers.pints_optimisers.PSO'>",
                "<class 'pybop.optimisers.pints_optimisers.SNES'>",
                "<class 'pybop.optimisers.pints_optimisers.XNES'>"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "5ce5c3da106bc177978201b289782207555f5c49793b272646bdc65aff14a57e",
        "warmup_time": -1
    },
    "benchmark_track_parameterisation.BenchmarkTrackParameterisation.track_x1": {
        "code": "class BenchmarkTrackParameterisation:\n    def track_x1(self, model, parameter_set, optimiser):\n        return self.x[0]\n\n    def setup(self, model, parameter_set, optimiser):\n        \"\"\"\n        Set up the parameterization problem for benchmarking.\n    \n        Args:\n            model (pybop.Model): The model class to be benchmarked.\n            parameter_set (str): The name of the parameter set to be used.\n            optimiser (pybop.Optimiser): The optimiser class to be used.\n        \"\"\"\n        # Set random seed\n        set_random_seed()\n    \n        # Create parameter values\n        parameter_values = pybamm.ParameterValues(parameter_set)\n        parameter_values.update(\n            {\n                \"Negative electrode active material volume fraction\": 0.63,\n                \"Positive electrode active material volume fraction\": 0.51,\n            }\n        )\n    \n        # Generate synthetic data\n        sigma = 0.003\n        t_eval = np.arange(0, 900, 2)\n        solution = pybamm.Simulation(model, parameter_values=parameter_values).solve(\n            t_eval=t_eval\n        )\n        corrupt_values = solution[\"Voltage [V]\"](t_eval) + np.random.normal(\n            0, sigma, len(t_eval)\n        )\n    \n        # Create dataset\n        dataset = pybop.Dataset(\n            {\n                \"Time [s]\": t_eval,\n                \"Current function [A]\": solution[\"Current [A]\"](t_eval),\n                \"Voltage [V]\": corrupt_values,\n            }\n        )\n    \n        # Define fitting parameters\n        parameter_values.update(\n            {\n                \"Negative electrode active material volume fraction\": pybop.Parameter(\n                    pybop.Gaussian(0.55, 0.03, truncated_at=[0.375, 0.7]),\n                ),\n                \"Positive electrode active material volume fraction\": pybop.Parameter(\n                    pybop.Gaussian(0.55, 0.03, truncated_at=[0.375, 0.7]),\n                ),\n            }\n        )\n    \n        # Create fitting problem\n        simulator = pybop.pybamm.Simulator(\n            model, parameter_values=parameter_values, protocol=dataset\n        )\n        cost = pybop.SumSquaredError(dataset)\n        problem = pybop.Problem(simulator, cost)\n    \n        # Create optimization instance and set options for consistent benchmarking\n        if optimiser is pybop.SciPyDifferentialEvolution:\n            options = pybop.SciPyDifferentialEvolutionOptions(maxiter=50)\n        elif optimiser is pybop.SciPyMinimize:\n            options = pybop.SciPyMinimizeOptions(maxiter=250)\n        else:\n            options = pybop.PintsOptions(\n                max_iterations=250,\n                max_unchanged_iterations=25,\n                threshold=1e-5,\n                min_iterations=2,\n            )\n        self.optim = optimiser(problem, options=options)\n    \n        # Track output results\n        self.x = self.results_tracking(model, parameter_set, optimiser)",
        "name": "benchmark_track_parameterisation.BenchmarkTrackParameterisation.track_x1",
        "param_names": [
            "model",
            "parameter_set",
            "optimiser"
        ],
        "params": [
            [
                "<pybamm.models.full_battery_models.lithium_ion.spm.SPM object>",
                "<pybamm.models.full_battery_models.lithium_ion.spme.SPMe object>"
            ],
            [
                "'Chen2020'"
            ],
            [
                "<class 'pybop.optimisers.scipy_optimisers.SciPyMinimize'>",
                "<class 'pybop.optimisers.scipy_optimisers.SciPyDifferentialEvolution'>",
                "<class 'pybop.optimisers.pints_optimisers.AdamW'>",
                "<class 'pybop.optimisers.pints_optimisers.CMAES'>",
                "<class 'pybop.optimisers.pints_optimisers.GradientDescent'>",
                "<class 'pybop.optimisers.pints_optimisers.IRPropMin'>",
                "<class 'pybop.optimisers.pints_optimisers.PSO'>",
                "<class 'pybop.optimisers.pints_optimisers.SNES'>",
                "<class 'pybop.optimisers.pints_optimisers.XNES'>"
            ]
        ],
        "type": "track",
        "unit": "unit",
        "version": "338a137b5591c9ec1e1b1e234691c852bae063e9aab2de9e294134759a8f2097"
    },
    "benchmark_track_parameterisation.BenchmarkTrackParameterisation.track_x2": {
        "code": "class BenchmarkTrackParameterisation:\n    def track_x2(self, model, parameter_set, optimiser):\n        return self.x[1]\n\n    def setup(self, model, parameter_set, optimiser):\n        \"\"\"\n        Set up the parameterization problem for benchmarking.\n    \n        Args:\n            model (pybop.Model): The model class to be benchmarked.\n            parameter_set (str): The name of the parameter set to be used.\n            optimiser (pybop.Optimiser): The optimiser class to be used.\n        \"\"\"\n        # Set random seed\n        set_random_seed()\n    \n        # Create parameter values\n        parameter_values = pybamm.ParameterValues(parameter_set)\n        parameter_values.update(\n            {\n                \"Negative electrode active material volume fraction\": 0.63,\n                \"Positive electrode active material volume fraction\": 0.51,\n            }\n        )\n    \n        # Generate synthetic data\n        sigma = 0.003\n        t_eval = np.arange(0, 900, 2)\n        solution = pybamm.Simulation(model, parameter_values=parameter_values).solve(\n            t_eval=t_eval\n        )\n        corrupt_values = solution[\"Voltage [V]\"](t_eval) + np.random.normal(\n            0, sigma, len(t_eval)\n        )\n    \n        # Create dataset\n        dataset = pybop.Dataset(\n            {\n                \"Time [s]\": t_eval,\n                \"Current function [A]\": solution[\"Current [A]\"](t_eval),\n                \"Voltage [V]\": corrupt_values,\n            }\n        )\n    \n        # Define fitting parameters\n        parameter_values.update(\n            {\n                \"Negative electrode active material volume fraction\": pybop.Parameter(\n                    pybop.Gaussian(0.55, 0.03, truncated_at=[0.375, 0.7]),\n                ),\n                \"Positive electrode active material volume fraction\": pybop.Parameter(\n                    pybop.Gaussian(0.55, 0.03, truncated_at=[0.375, 0.7]),\n                ),\n            }\n        )\n    \n        # Create fitting problem\n        simulator = pybop.pybamm.Simulator(\n            model, parameter_values=parameter_values, protocol=dataset\n        )\n        cost = pybop.SumSquaredError(dataset)\n        problem = pybop.Problem(simulator, cost)\n    \n        # Create optimization instance and set options for consistent benchmarking\n        if optimiser is pybop.SciPyDifferentialEvolution:\n            options = pybop.SciPyDifferentialEvolutionOptions(maxiter=50)\n        elif optimiser is pybop.SciPyMinimize:\n            options = pybop.SciPyMinimizeOptions(maxiter=250)\n        else:\n            options = pybop.PintsOptions(\n                max_iterations=250,\n                max_unchanged_iterations=25,\n                threshold=1e-5,\n                min_iterations=2,\n            )\n        self.optim = optimiser(problem, options=options)\n    \n        # Track output results\n        self.x = self.results_tracking(model, parameter_set, optimiser)",
        "name": "benchmark_track_parameterisation.BenchmarkTrackParameterisation.track_x2",
        "param_names": [
            "model",
            "parameter_set",
            "optimiser"
        ],
        "params": [
            [
                "<pybamm.models.full_battery_models.lithium_ion.spm.SPM object>",
                "<pybamm.models.full_battery_models.lithium_ion.spme.SPMe object>"
            ],
            [
                "'Chen2020'"
            ],
            [
                "<class 'pybop.optimisers.scipy_optimisers.SciPyMinimize'>",
                "<class 'pybop.optimisers.scipy_optimisers.SciPyDifferentialEvolution'>",
                "<class 'pybop.optimisers.pints_optimisers.AdamW'>",
                "<class 'pybop.optimisers.pints_optimisers.CMAES'>",
                "<class 'pybop.optimisers.pints_optimisers.GradientDescent'>",
                "<class 'pybop.optimisers.pints_optimisers.IRPropMin'>",
                "<class 'pybop.optimisers.pints_optimisers.PSO'>",
                "<class 'pybop.optimisers.pints_optimisers.SNES'>",
                "<class 'pybop.optimisers.pints_optimisers.XNES'>"
            ]
        ],
        "type": "track",
        "unit": "unit",
        "version": "8f76885140d4106ab7ecc834fac827bc257458f2082d43df3b8af4845f20db86"
    },
    "version": 2
}